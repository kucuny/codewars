"""
Title : Befunge Interpreter

Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions (from Wikipedia):

0-9 Push this number onto the stack.
+ Addition: Pop a and b, then push a+b.
- Subtraction: Pop a and b, then push b-a.
* Multiplication: Pop a and b, then push a*b.
/ Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
% Modulo: Pop a and b, then push the b%a. If a is zero, push zero.
! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
` Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
> Start moving right.
< Start moving left.
^ Start moving up.
v Start moving down.
? Start moving in a random cardinal direction.
_ Pop a value; move right if value = 0, left otherwise.
| Pop a value; move down if value = 0, up otherwise.
" Start string mode: push each character's ASCII value all the way up to the next ".
: Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
\ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
$ Pop value from the stack and discard it.
. Pop value and output as an integer.
, Pop value and output the ASCII character represented by the integer code that is stored in the value.
# Trampoline: Skip next cell.
p A "put" call (a way to store a value for later use). Pop y, x and v, then change the character at the position (x,y) in the program to the character with ASCII value v.
g A "get" call (a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.
@ End program.
 (i.e. a space) No-op. Does nothing.
The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

Here's an example:

>987v>.v
v456<  :
>321 ^ _@
will create the output 123456789.

So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example,

interpret('>987v>.v\nv456<  :\n>321 ^ _@') == '123456789'
This test case will be added for you.
"""

import unittest

import random


def interpret(code):
    befunge = Befunge(code)
    res = befunge.run()
    return res


class Befunge:
    def __init__(self, code):
        self.code = list(code)
        self.matrix = [['' for col in range(100)] for row in range(100)]
        self.stack = []
        self.current_row = 0
        self.current_col = 0
        self.current_direction = '>'
        self.is_ended = False

        self.BEFUNGE_CODE_TABLE = {
            '0': self.__push_num,
            '1': self.__push_num,
            '2': self.__push_num,
            '3': self.__push_num,
            '4': self.__push_num,
            '5': self.__push_num,
            '6': self.__push_num,
            '7': self.__push_num,
            '8': self.__push_num,
            '9': self.__push_num,
            '+': self.__add,
            '-': self.__subtract,
            '*': self.__multiple,
            '/': self.__divide,
            '%': self.__mod,
            '!': self.__not,
            '`': self.__gt,
            '>': self.__moving_right,
            '<': self.__moving_left,
            '^': self.__moving_up,
            'v': self.__moving_down,
            '?': self.__moving_random_direction,
            '_': self.__moving_by_cond_right_left,
            '|': self.__moving_by_cond_up_down,
            '"': self.__string_mode,
            ':': self.__duplicate,
            '\\': self.__swap,
            '$': self.__discard,
            '.': self.__get_integer,
            ',': self.__get_char,
            '#': self.__trampoline,
            'p': self.__put_to_xy,
            'g': self.__get_from_xy,
            '@': self.__end,
            ' ': self.__nothing,
        }

        self.__init_matrix()
        self.result = []

    def run(self):
        while not self.is_ended:
            self.BEFUNGE_CODE_TABLE[self.matrix[self.current_row][self.current_col]]()
            self.__moving()

        return ''.join(self.result)

    def __init_matrix(self):
        row = 0
        col = 0
        for c in self.code:
            if c == '\n':
                row += 1
                col = 0
            else:
                self.matrix[row][col] = c
                col += 1

    def __pop(self):
        try:
            res = self.stack.pop()
        except:
            res = 0
        return res

    def __push(self, s):
        self.stack.append(s)

    def __direction(self, direction):
        self.current_direction = direction

    def __push_num(self):
        self.__push(int(self.matrix[self.current_row][self.current_col]))

    def __add(self):
        x = self.__pop()
        y = self.__pop()
        self.__push(x + y)

    def __subtract(self):
        x = self.__pop()
        y = self.__pop()
        self.__push(y - x)

    def __multiple(self):
        x = self.__pop()
        y = self.__pop()
        self.__push(x * y)

    def __divide(self):
        x = self.__pop()
        y = self.__pop()
        if y == 0:
            self.__push(0)
        else:
            self.__push(round(y / x, 0))

    def __mod(self):
        x = self.__pop()
        y = self.__pop()
        if x == 0:
            self.__push(0)
        else:
            self.__push(y % x)

    def __not(self):
        x = self.__pop()
        if x == 0:
            self.__push(1)
        else:
            self.__push(0)

    def __gt(self):
        x = self.__pop()
        y = self.__pop()
        if y > x:
            self.__push(1)
        else:
            self.__push(0)

    def __moving_right(self):
        self.__direction('>')

    def __moving_left(self):
        self.__direction('<')

    def __moving_up(self):
        self.__direction('^')

    def __moving_down(self):
        self.__direction('v')

    def __moving_random_direction(self):
        direction = ['>', '<', '^', 'v']
        self.__direction(direction)
        self.BEFUNGE_CODE_TABLE[random.choice(direction)]()

    def __moving_by_cond_right_left(self):
        x = self.__pop()
        if x == 0:
            self.BEFUNGE_CODE_TABLE['>']()
        else:
            self.BEFUNGE_CODE_TABLE['<']()

    def __moving_by_cond_up_down(self):
        x = self.__pop()
        if x == 0:
            self.BEFUNGE_CODE_TABLE['v']()
        else:
            self.BEFUNGE_CODE_TABLE['^']()

    def __string_mode(self):
        self.__moving()
        n = ord(str(self.matrix[self.current_row][self.current_col]))
        while n != 34:
            self.__push(n)
            self.__moving()
            n = ord(str(self.matrix[self.current_row][self.current_col]))

    def __duplicate(self):
        x = self.__pop()
        self.__push(x)
        self.__push(x)

    def __swap(self):
        x = self.__pop()
        y = self.__pop()
        self.__push(x)
        self.__push(y)

    def __discard(self):
        self.__pop()

    def __end(self):
        self.is_ended = True

    def __get_integer(self):
        self.result.append(str(self.__pop()))

    def __get_char(self):
        self.result.append(chr(self.__pop()))

    def __trampoline(self):
        self.__moving()

    def __put_to_xy(self):
        x = self.__pop()
        y = self.__pop()
        v = self.__pop()

        self.matrix[x][y] = chr(v)

    def __get_from_xy(self):
        y = self.__pop()
        x = self.__pop()

        self.__push(ord(self.matrix[y][x]))

    def __nothing(self):
        pass

    def __moving(self, count=1):
        if self.current_direction == '>':
            self.current_col += count
        elif self.current_direction == '<':
            self.current_col -= count
        elif self.current_direction == '^':
            self.current_row -= count
        elif self.current_direction == 'v':
            self.current_row += count


class TestBefunge(unittest.TestCase):
    def test_befunge_is_valid(self):
        self.assertEqual('120', interpret('05>:1-:v v *_$.@\n  ^    _$>\:^'))
        self.assertEqual('123456789', interpret('>987v>.v\nv456<  :\n>321 ^ _@'))
        self.assertEqual('Hello world!', interpret('"!dlrow olleH">:#,_@'))
        self.assertEqual('01->1# +# :# 0# g# ,# :# 5# 8# *# 4# +# -# _@',
                         interpret('01->1# +# :# 0# g# ,# :# 5# 8# *# 4# +# -# _@'))
        self.assertEqual('2357111317192329313741434753596167717379',
                         interpret('2>:3g" "-!v\  g30          <\n |!`"O":+1_:.:03p>03g+:"O"`|\n @               ^  p3\\" ":<\n2 234567890123456789012345678901234567890123456789012345678901234567890123456789'))
